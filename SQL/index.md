# index 타면 왜 빨라지는가.

index의 종류에는 여러가지가 있는데 
B-tree 인덱스, 비트맵 인덱, IOT, 클러스터형 인덱스가 있고
주로 사용하는 인덱스는 B-tree 인덱스이다.

인덱스도 오브젝트의 하나이고, 인덱스가 생성되면
테이블과 매핑된 또다른 테이블이 하나 생성된다고 생각하면 될 것 같다.
여기서 질문이 있을 수 있는데 테이블이 하나 더 생겼는데 
어떻게 속도가 빨라지나요? 라는 질문이 있을 수 있다.

인덱스는 저장방식이 인덱스 컬럼을 기준으로 소팅이 되어서 저장이 되어있다.
보통 테이블은 데이터들이 물리적으로 흩어져서 저장이 되어있어서
어떤 특정 조건의 데이터들을 찾으려면 테이블 풀스캔을 해야한다.
만약 테이블 안의 데이터들이 방대하다면 시간이 엄청 걸리게 된다.

그런데 인덱스는 정렬되어서 저장이 되어 있기 때문에
특정 조건의 데이터들을 검색을 할때 시작점을 지정을 해서 거기서부터 검색을 할 수 
있는 것이다.

인덱스가 테이블과 매핑 되어 있다.
인덱스에서 먼저 데이터들을 찾은다음에 그 테이블로 매핑된 곳을 가서 나머지 테이블들을
꺼내오는 방식.

인덱스는 포인터처럼 인덱스가 해당 테이블의 블럭에 주소를 가지고 있다고 생각하며 된다.
여기서 블럭은 데이터가 저장되는 최소 단위이고 거기엔 테이블의 데이터들이 
로우 단위로 저장이 되어있다.
만약에 테이블의 컬럼의 수가 많다면
하나의 블럭에 저장되는 로우수가 적어지겠고
만약에 테이블의 컬럼수가 적다면
하나의 블럭에 저장되는 로우수가 많아진다.

어떤 컬럼을 인덱스로 설정을 해야 효과가 좋을까.
where절에 자주 등장하는 컬럼을 인덱스로 설정해야 효과가 좋다.
2번째는 order by절 . order by절에 자주 등장하는 컬럼을 인덱스로 지정을 하면
인덱스는 소팅이 되어서 저장되어 있다고 했기 때문에
별도로 order by를 할 필요없이 바로바로 꺼내서 쓰면 되기 때문에 효율적이다.

그리고 인덱스는 단일 컬럼으로 구성할 수도 있지만
여러 컬럼을 조합해서 결합인덱스로 구성할 수도 있다.
그럴 경우에는 select절에 등장하는 컬럼들을
잘 조합을 해서 인덱스로 구성을 해놓으면
별도로 테이블에 가서 꺼내올 필요없이
인덱스만 스캔을 해서 바로 출력을 하면 되니깐 되게 빠르게 되겠죠.

그런데 이렇게 좋다고 해서 인덱스를 마구잡이로 생성을 하면 안된다.
인덱스가 오브젝트이기 때문에 많이 만들면 select는 빨라질 지 몰라도
insert나 update는 오히려 느려진다.
왜냐하면 특히 insert같은 경우에는 인덱스가 정렬이 된 상태로 저장을 하여야 되기 때문에
어느자리에 넣어야 할지 찾아야 하기 때문에
그리고 테이블에만 insert나 update를 하는 것이 아니라
인덱스도 똑같이 해줘야 되기 때문에
두군데에다 하니깐 오히려 느려진다.
결합인덱스 같은 경우네느 결합하는 순서가 굉장히 중요한데
where 절에서 equal에 쓰이는 컬럼이 앞에 오는게 효율적이고
분별력이 높은 컬럼이 앞으로 오는게 효율적이다.

예를 들어 성별 같은 컬럼 보다는 아이디 같이 분별력이 높은 컬럼이 앞으로 와야
바로 인덱스를 스캔 할수 있다.

인덱스 스캔 방식에도 특정 시작점부터 범위를 스캔하는 방식을
index range scan 이라고 하고 index full scan도 있고 
index skip scan, index fast full scan도 있으니깐 참고하면 좋다.

그리고 인덱스를 탄다고 해서 무조건 속도가 빨라지는건 아니다 
인덱스 손익분기점이라는게 있는데 테이블이 가지고 있는 전체 데이터양의 10에서 15프로
이내의 데이터가 출력이 될때만 인덱스를 타는게 효율적이고 
그 이상이 될때는 오히려 풀스캔을 하는게 더 빠르다.

----------------------------------------------------------------------------

### 인덱스를 실제로 어떻게 사용하면 되는지.

    CREATE INDEX IDX_SB1 ON STARBUCKS_ORDER (REG_NAME);

으로 STARTBUCKS_ORDER테이블의 REG_NAME을 인덱스로하는 인덱스명이 IDX_SB1인 인덱스를 만들 수 있다.

    SELECT * FROM STARBUCKS_ORDER WHERE REG_NAME = '봄';

그냥 이렇게 하면 TABLE FULL SCAN을 했지만 위의 인덱스를 만들고 나서 실행을 하면 INDEX RANGE SCAN을 하는것을 볼 수 있다.

테이블 실행계획 확인은 
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'))

을 하면 되는 것 같다.

    SELECT /* +INDEX(STARBUCKS_ORDER IDX_SB1)*/ * FROM STARBUCKS_ORDER WHERE REG_NAME = '봄';

이런식으로 적으면 오라클 힌트라서 이것을 실행할 때는 이 인덱스를 타라고 명시해주는 것 같다.
하지만 이 오라클 힌트를 무분별하게 남발하는건 지양해야한다고 했다.

왜냐하면 옵티마이저가 알아서 인덱스가 나을지 테이블 풀스캔이 좋을지 판단을 해서 실행하게 되어있기 때문에..
옵티마이저는 CBO라고 해서 실행을 할 때 비용이 덜 드는 방향으로 알아서 한다.
다만 한 테이블에 인덱스가 너무 많이 생성이 되어있으면 옵티마이저가 오류가 나서 판단미스가 날 때가 있는데 이 때 꼭 이 인덱스를 타라고 오라클힌트로 명시를 해주면 된다.



