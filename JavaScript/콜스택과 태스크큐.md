## 콜스택과 태스크 큐 

콜스택과 태스크큐에 대해서 공부해볼 것이다.
자바스크립트 타이머 setTimeout이 설정한 시간 뒤에 시작 되지 않고 좀 더 있다가 실행 되는 이유 같은 것을 공부할 것이다.

그 이유는 싱글 콜 스택 때문이라고 하는데 javascript가 싱글 스레드로 진행되기 때문이라 할 수 있다.

예를 들어 

    function yo() {
        setTimeout(function () {
            console.log('1.5초 타이머 끝!');
        }, 1500);

        for(let i = 0; i<3; i++){
            doSomething();
            console.log(i);
        }
        console.log('3초 걸리는 for문 끝!');
    }

    yo();

    console.log('main 끝!');


이걸 실행을 하면 1.5초뒤에 for문이 실행될 것 같지만 현실은 그렇지 않다. 왜냐하면 javascript의 timer는 외부 api에 있기 때문에 콜스택이 다르게 된다. 무슨 말이냐면...
전체를 main이라고 할때 main이 태스크 큐에 들어갔다가 실행되면 콜스택에 들어가게된다. setTimeout이 콜스택에 들어가고 실행되면 백그라운드로 보내지고 1.5초뒤에 콜백함수를 태스크큐에 넣는다. setTimeout은 콜스택에서 사라진다. 그리고 for문이 돌아가고 콜스택에 들어왔다가 실행되면 사라지고를 반복하고~~ 한다. 즉 1.5초뒤에 실행되는 콜백함수는 main까지 다 끝난다음에 태스크큐에서 콜스택으로 올라와서 실행되게 된다. 
for문과 console.log 등이 다 실행되고 난 다음에 실행되는 것이다. 그래서 1.5초뒤에 for문이 돌아가는 것이 아니라 바로바로 실행되어 
0, 1, 2 , '3초 걸리는 for문 끝!', 'main 끝!' 다음에 '1.5초 타이머 끝!' 순서대로 출력된다.
setTimeout이 0초를 기다리게 해도 맨 마지막에 실행되는 이유가 이것이다.

Uncaught RangeError: Maximun call stack size exceeded

호출 스택이 가득 찼을 때 발생하는 에러. 재귀함수같이 함수 안에서 계속 다른 함수를 호출하다보면 저기 스택이 가득 차다못해 터져버린다. 그래서 나오는 에러. 브라우저마다 호출 스택 최대치가 다른데. 요즘은 10만개가 넘는 브라우저도 있다. 하지만 보통 만 개 정도라고 생각하면 편함.

### 이벤트 루프

이벤트 루프는 실행 컨텍스트와 함께 필수적으로 알고 있어야 하는 개념. 자바스크립트와 노드에서 사용되는데, 자바스크립트는 보통 싱글 쓰레드라고 불리는데, 바로 메인 쓰레드인 이벤트 루프가 싱글 쓰레드이기 때문이다.

setTimeout을 하는 순간 백그라운드를 거쳐 태스크 큐로 콜백함수가 이동하고 main함수가 끝나고 run이 실행된다. (사실 setTimeout 0도 기본적으로 4ms의 지연 시간을 갖고 있어서 setTimeout 4ms와 마찬가지이다. 노드는 1ms의 지연 시간을 가지고 있다.)

백그라운드에서 3초를 정확하게 세어 주었다고 하더라도, 호출 스택에 함수들이 가득차 있다면 3초 후에 실행되지 않을 수도 있다. 이벤트 루프가 태스크 큐에서 run 함수를 호출 스택으로 끌어올리지 못하기 때문에.. 콜스택(호출스택)이 이벤트루프가 태스크큐의 함수를 콜스택으로 끌어올릴 수 있다. setTimeout의 초가 정확하지 않을 수도 있는 이유. 호출 스택에서 너무 많은 일을 하게 되면 태스크 큐에 쌓인 콜백 함수들이 제 때에 실행되지 않기 때문에 너무 버거운 일들은 하지 않는게 좋다.

위에서 나왔던 Maximum call stack size exceeded 에러도 setTimeout 0을 사용해서 극복할 수 있다. setTimeout을 하는 순간 호출 스택에 함수가 쌓이는게 아니라 백그라운드드를 거쳐 태스크 큐로 넘어가기 때문에 호출 스택이 터지는 일이 발생하지 않는다.