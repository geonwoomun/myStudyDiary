웹팩을 사용하기 위해서는 Node.js와 NPM이 컴퓨터에 설치되어 있어야한다.

Node.js 브라우저 밖에서도 자바스크립트를 실행할 수 있는 환경을 의미한다. Node.js가 나오기 전까지는 자바스크립트가 브라우저의 동작을 제어하는데 사용되었고 브라우저에서만 실행할 수 있었지만 이제는 Node.js로 자바스크립트를 브라우저 밖에서도 실행할 수 있게 되었다.

NPM(Node Package Manager)는 명령어로 자바스크립트 라이브러리를 설치하고 관리할 수 있는 패키지 매니저이다. NPM 공식 사이트에서도 안내가 되어 있지만 전 세계 자바스크립트 개발자들이 모두 자바스크립트 라이브러리를 공개된 저장소에 올려놓고 npm 명령어로 편하게 다운로드 받을 수 있다. npm은 Node.js를 설치하면 같이 설치된다.

npm init -y 를 하면 package.json 파일이 생성된다. 자주 사용되는 속성은 scripts, dependencies, devDependencies이다.

package.json의 scripts에는 커스텀 명령어를 만들 수 있다. NPM 커스텀 명령어는 모두 npm run 명령어이름 형식으로 실행할 수 있다.
npm start는 그냥도 가능하고 npm run start도 가능하다.

NPM 커스텀 명령어는 웹팩 같은 도구 뿐만 아니라 Node.js 등을 사용할 때도 유용하다. 실행하려는 명령어가 길수록 더 빛을 발휘한다.

프로젝트 폴더 루트 레벨에 webpack.config.js 파일을 생성해서 설정을 할 수 있다.


    const path = require('path');
    
    module.exports = {
        mode: 'none',
        entry: './src/index.js',
        output: {
            filename: 'main.js',
            path: path.resolve(__dirname, 'dist')
        }
    };

이제 package.json의 scripts에 "build": "webpack"을 적어주고 npm run build를 실행해주면 된다. 또는 npx webpack

entry 속성은 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로이다.

    module.exports = {
        entry: './src/index.js'
    }

위 코드는 웹팩을 실행했을 때 src 폴더 밑의 index.js을 대상으로 웹팩이 빌드를 수행하는 코드이다.

entry 속성에 지정된 파일에는 웹 애플리케이션의 전반적인 구조와 내용이 들어가 있어야한다. 웹팩이 해당 파일을 가지고 웹 애플리케이션에서 사용되는 모듈들의 연관 관계를 이해하고 분석하기 때문에 애플리케이션을 동작시킬 수 있는 내용들이 담겨져 있어야한다.

엔트리 포인트는 1개가 될 수도 있지만 여러개가 될 수도 있다. 엔트리 포인트를 분리하는 경우에는 싱글 페이지 애플리케이션이 아닌 특정 페이지로 진입했을 때 서버에서 해당 정보를 내려주는 형태의 멀티 페이지 애플리케이션에 적합하다.

Output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미한다.

    module.exports = {
        output: {
            filename: 'bundle.js'
        }    
    }

앞에서 배운 entry 속성과는 다르게 객체 형태로 옵션들을 추가해야 한다.

최소한 filename은 지정해줘야 하며 일반적으로 아래와 같이 path 속성을 함께 정의해준다.

    let path = require('path');

    module.exports = {
        output: {
            filename: 'bundle.js',
            path: path.resolve(__dirname, './dist')
        }
    }


Loader 로더는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹자원(HTML, CSS, Images, 폰트 등)들을 변환할 수 있도록 도와주는 속성이다.

    module.exports = {
        module: {
            rules: []
        }
    }
엔트리나 아웃풋 속성과는 다르게 module이라는 이름을 사용.

webpack은 기본적으로 js만 해주기 때문에 css는 번들링을 못 해줌. css-loader를 통해서 가능하게 만들 수 있다.

    module.exports = {
        entry: './app.js',
        output: {
            filename: 'bundle.js'
        },
        module: {
            rules: [
                {
                    test: /\.css$/,
                    use: ['css-loader']
                }
            ]
        }
    }

module 쪽 코드를 보면 rules 배열에 객체 한 쌍을 추가했습니다.
test: 로더를 적용할 파일 유형(일반적으로 정규 표현식 사용)
use: 해당 파일에 적용할 로더의 이름.

정리하자면 위 코드는 해당 프로젝트의 모든 CSS파일에 대해서 CSS로더를 적용하겠따는 의미.

CSS로더 이외에도 실제 서비스를 만들 때 자주 사용되는 로더는 Babel Loader, Sass Loader, File Loader, TS Loader 등이 있다.

로더는 기본적으로 오른쪽에서 왼쪽 순으로 적용된다.

Plugin은 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성이다. 로더랑 비교하면 로더는 파일을 해석하고 변환하는 과정에 관여하는 반면, 플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다.

    module.exports = {
        plugins: []
    }

플러그인의 배열에는 생성자 함수로 생성한 객체 인스턴스만 추가될 수 있다. 

    const webpack = require('webpack');
    const HtmlWebpackPlugin = require('html-webpack-plugin');

    module.exports = {
        plugins: [
            new HtmlWebpackPlugin(),
            new webpack,ProgressPlugin
        ]
    }

위 두 플러그인은 각각 아래와 같은 역할을 한다.

HtmlWebpackPlugin : 웹팩으로 빌드한 결과물로 HTML 파일을 생성해주는 플러그인
ProgressPlugin : 웹팩의 빌드 진행율을 표시해주는 플러그인
