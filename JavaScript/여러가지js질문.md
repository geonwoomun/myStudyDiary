## 이벤트 위임에 대해 설명

이벤트 위임은 이벤트 리스너를 하위 요소에 추가하느 대신에 상위 요소에 추가하는 기법.
리스너는 DOM event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행된다.
이 기술을 이점은 다음과 같다.

 * 각 하위 항목에 이벤트 핸드럴르 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어든다.
 * 제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없다.

 ## this가 JavaScript에서 어떻게 작동하는지 설명하세요

 this는 간단하게 설명하기 어렵다. JavaScript에서 가장 혼란스러운 개념 중 하나이다. 대략 설명하는 this의 값은 함수가 호출하는 방식에 따라 달라진다. 

1. 함수를 호출할 때 new 키워드를 사용하는 경우, 함수 내부에 있는 this는 완전히 새로운 객체이다.
2. apply, call, bind가 함수의 호출/생성에 사용되는 경우, 함수 내의 this는 인수로 전달된 객체이다.
3. obj.method()와 같이 함수를 메서드로 호출하는 경우, this는 함수가 프로퍼티인 객체이다.
4. 함수가 자유함수로 호출되는 경우, 위의 조건 없이 호출되는 경우 this는 전역 객체이다. 브라우저에서는 window 객체이다. 엄격모드 ('use strict') 일 경우, this는 전역객체 대신 undefined가 된다.
5. 위의 규칙 중 다수가 적용되면 더 상위 규칙이 승리하고 this 값을 설정.
6. 함수가 ES2015 화살표 함수인 경우 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this값을 받는다.

## 프로토타입 상속이 어떻게 작동하는지 설명하라.

매우 일반적이 JS인터뷰 질문이다. 모든 JS객체는 다른 객체에 대한 참조인 prototype 프로퍼티를 가지고 있다. 객체의 프로퍼티에 접근할 때, 해당 객체에 해당 프로퍼티가 없으면 js 엔진은 객체의 prototype과 prototype의 prototype 등을 보고 프로퍼티 정의가 있을 때까지 찾고, 만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 프로토타입 체인중 하나에 있거나 프로토타입 체인의 끝에 도달할 때까지 찾는다. 이 동작은 고전적인 상속을 흉내내지만, 실제로 상속보다 위임에 가깝다.

### AMD vs CommonJS에 대해 어떻게 생각하는가.

두 가지 모두 es2015가 등장하기 전까지 JS에 기본적으로 존재하지 않는 모듈 시스템을 구현하는 방법이다.
CommonJS는 동기식인 반면 AMD는 비동기식이다. CommnJS는 서버사이드 개발을 염두에 두고 설계되었으며, AMD는 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용된다.

AMD는 구문이 매우 장황하고, CommonJS는 다른 언어처럼 import 문을 작성하는 스타일에 더 가깝다. 대부분의 경우 AMD를 필요로하지 않는다. 모든 JS를 연결된 하나의 번들 파일로 제공하면 비동기 로딩 속성의 이점을 누릴 수 없기 때문이다. 또한 CommonJS 구문의 모듈 작성의 노드 스타일에 가깝고 클라이언트 사이드와 서버사이드 JS개발 사이를 전환할 때 문맥 전환 오버 헤드가 적다.

ES2015 모듈이 동기식 및 비동기식 로딩을 모두 지원하는 것이 바운것은 마침내 하나의 접근 방식만 고수할 수 있다는 점이다. 브라우저와 노드에서 완전히 작동되지는 않지만 언제나 트랜스파일러를 사용하여 코드를 변환할 수 있다.

## null, undefined, undeclared의 차이점은 무엇인가요? 어떻게 이 상태들에 대한 확인을 할 것인가?

Undeclared 변수는 이전에 var, let, const를 사용하여 생성되지 않은 식별자에 값을 할당할 때 생성된다. Undecalred 변수는 현재 범위 외부에 전역으로 정의된다. strict 모드에서는 Undeclared 변수에 할당하려고 할 때 , ReferenceError가 발생한다.

undefined 변수는 선언되었지만, 값이 할당되지 않은 변수이다. 이는 undefined 타입이다. 함수가실행 결과에 따라 아무값도 반환하지 않으면, 변수에 할당되며, 그 변수가 undefined 값을 갖는다. 이를 검사하기 위해, 엄격한 === 연산자 또는 typeof에 undefined 문자열을 사용하여 비교하라. 확인을 위해 추상 평등 연산자 ==를 사용해서는 안된다. 이는 값이 null이면 true를 반환함!

null인 변수는 null 값이 명시적으로 할당된 것. 그것은 값을 나타내지 않으며, 명시적으로 할당됐다는 점에서 undefined와 다르다. null을 체크하기 위해서 단순히 ===를 사용하여 비교하면 된다. 위와 같이 ==를 사용하면 안된다.

undeclared나 undefined로 두기보다 아직 사용하지 않으려는경우 선언한 후에 명시적으로 null을 할당하는 것이 좀 더 좋을듯!!

## 클로저는 무엇이며, 어떻게/왜 사용하나?

클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다. "렉시컬"은 렉시컬 범위 지정이변수가 사용 가능한 위치를 결정하기 위해 소스 코드 내에서 변수가 선언된 위치를 사용한다는 사실을 나타낸다. 클로저는 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수이다.

클로저로 데이터 프라이버시/ private method를 모방. 일반적으로 모듈 패턴에 사용.
부분 적용 또는 currying

## .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 왜 둘 중 하나를 선택할 것인가요?

forEach
* 배열의 요소를 반복한다.
* 각 요소에 대해 콜백을 실행한다.
* 값을 반환하지 않는다.

map
* 배열의 요소를 반복한다.
* 각 요소에서 함수를 호출하여 결과로 새 배열을 작성하여 각 요소를 새 요소에 매핑한다.

.forEach와 .map()의 가장 큰 차이점은 .map()이 완전히 새로운 배열을 반환한다는 것이다. 결과가 필요하지만 원본 배열을 변경하지 않고 싶으면(불변성) .amp()이 확실한 선택이다. 단순히 배열을 반복할 필요가 있다면, forEach가 좋은 선택이다.

## 익명 함수의 일반적인 사용 사례는 무엇인가요?
익명함수는 IIFE로 사용되어 직역 범위 내에서 일부 코드를 캡슐화하므로 선언된 변수가 전역 범위로 누출되지 않는다.

한번 사용되고 다른 곳에서는 사용할 필요가 없는 콜백으로 사용. 함수 본체를 찾기 위해 다른 곳을 찾아볼 필요 없이 코드를 호출하는 코드 바로 안에 핸들러가 정의되어 있다면 코드가 보다 독립적이고 읽기 쉽게 보일 것이다.

## 호스트 객체와 내장 객체의 차이점은 무엇인가요?
내장 객체는 ECMAScript 사양에 정의된 JS언어의 일부인 객체 ( 예 String, Math, RegExp, Object, Function 등)

호스트 객체는 window, XMLTTHPRequest 등과 같이 런타임 환경(브라우저 or 노드)에 의해 제공 된다.
