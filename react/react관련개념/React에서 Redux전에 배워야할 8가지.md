# React에서 Redux 전에 배워야 할 8가지

상태 관리는 어렵다. React 같은 뷰 라이브러리는 지역 컴포넌트 상태를 관리하는 일이 가능하다. 하지만 이 상태는 특정 시점에서 확장해야 하는 일이 생긴다. 리액트는 단순히 뷰 계층 라이브러리이다. 언젠가는 Redux와 같이 더 수준 높은 상태 관리 솔루션으로 넘어가는 결정을 하게 될 것이다. 하지만 이 글에서는 Redux 열차에 올라타기 전에 React에서 알아야 하는 부분에 대해서 지적하고 싶다.

사람들은 간혹 React와 Redux를 함께 배운다. 하지만 거기에 문제점이 있다.

 1. 지역 상태만 사용하는 경우에 왜 상태 관리에 확장 문제가 발생하는지 겪어보지 못한다.
 그래서 왜 Redux 같은 상태 관리 라이브러리가 필요한지 이해하지 못 한다.
 그래서 너무 많은 보일러플레이트에 대해 불평한다.

 2. React에서 지역 상태를 관리하는 방법을 배우지 못한다.
 그래서 모든 상태를 Redux에서 제공하는 상태 컨테이너에 담아두고 관리하려고 한다. 그래서 지역 상태 관리를 전혀 사용하지 않게 된다.

이러한 문제점으로 인해 React를 먼저 배우고 나중에 필요하다고 느낄 때 Redux를 배우도록 조언한다. 확장 문제는 대형 어플리케이션에서만 나타난다. 가끔 Redux를 사용하고 있으면서도 상태 관리 라이브러리가 필요하지 않은 경우가 있다. 책 The Road to learn React에서는 Redux와 같은 외부 의존성 없이 있는 그대로의 React로 애플리케이션을 만드는 방법을 설명한다.

### 1. React에서의 지역상태는 자연스럽다.

이미 언급했지만 가장 중요한 조언은 React를 먼저 학습하라는 점이다. 컴포넡트에 지역 상태 즉, this.setState(), this.state, useState 등을 사용해서 생명을 불어 넣는 일을 피할 수는 없다.

React 컴포넌트는 초기 상태를 생성자(consturctor)에서 정의하고 있다.(물론 요즘은 constructor에서 안 해도 된다..) 그런 후에 this.setState()나 useState의 두번째 반환값으로 갱신 가능. 상태 객체의 갱신은 얕은 병합으로 수행된다. 그러므로 지역상태 객체를 부분적으로 갱신하고도 상태 겍체의 다른 프로퍼티는 손대지 않고 그대로 유지할 수 있다. 상태가 갱신된 후에는 컴포넌트가 다시 렌더링을 수행한다. 

### 2. 함수형 지역 상태

this.setState() 메소드는 지역상태를 비동기적으로 갱신한다. 그러므로 언제 상태가 갱신되는지에 대해 의존해서는 안된다. 상태 갱신은 결과적으로 나타난다. 대부분의 경우에는 이런 방식이 별 문제 없다.

하지만 컴포넌트의 다음 상태를 위해 연산을 하는데 현재 지역 상태에 의존한다고 가정해보자.

    this.setState({counter : this.state.counter + 1});

지역상태는 연산에서 바로 그 시점의 상태로 사용했다. 그러므로 this.setState를 사용해서 갱신하기 했지만 지역상태는 비동기 실행이 수행되기전에 신선하지 않은 상태값을 사용해 연산하게 된다. 이런점은 처음 보고 나서는 바로 파악하기 어렵다.

    this.setState({counter: this.state.counter + 1});
    this.setState({counter: this.state.counter + 1});
    this.setState({counter: this.state.counter + 1});

    // 예상한 상태 : { counter : 3}
    // 실제 갱신된 상태 : { counter : 1 }

이 코드에서 확인할 수 있는 것처럼 지역 상태를 갱신할 때 현재 상태에 의존해서는 안된다. 이런 접근 방식은 버그를 만든다. 그래서 이런 상황에서는 다음과 같은 방식으로 지역 상태를 갱신한다.

this.setState()에는 객체 대신 함수도 사용할 수 있다. 함수는 비동기적으로 this.setState가 실행될 때, 함수 시그니처에 지역 상태를 전달한다. 그래서 이 함수는 콜백 함수로 정학한 시점에 올바른 상태를 갖고 실행되기 때문에 문제없이 사용할 수 있게 된다.

    this.setState(previousState => ({counter: previousState.counter + 1}));

이 방법으로 this.setState()를 여전히 이용하면서도 객체 대신 함수를 사용해서 이전 상태를 활용할 수 있다.

추가적으로 프로퍼티(props)에 의존적인 갱신이 필요한 경우에도 이 접근 방식을 따라야 한다. 비동기적 실행이 수행되기 이전에 부모 컴포넌트에서 받은 프로퍼티가 변경되어서 값이 이전 정보가 되는 경우가 있기 때문이다. 그래서 this.setState()의 두번째 인자로 프로퍼티가 전달된다.

    this.setState((prevState, props) => ...);

이제 올바른 상태와 프로퍼티를 사용해서 상태를 갱신할 수 있다.

### 3. React의 상태와 프로퍼티

상태는 컴포넌트 안에서 관리된다. 이 상태는 다른 컴포넌트에 프로퍼티로 내려줄 수 있다. 이 컴포넌트는 프로퍼티를 사용하거나 더 깊히 자식 컴포넌트로 전달 할 수 있따. 덧붙여 자식 컴포넌트는 부모 컴포넌트로부터 콜백 함수를 전달 받을 수 있다. 이렇게 전달 받은 함수를 사용하면 부모컴포넌트의 지역 상태를 변경하는 일도 가능하다. 기본적으로 프로퍼티는 컴포넌트 트리를 타고 내려간다. 상태는 하나의 컴포넌트에서 관리한다. 하위 컴포넌트에서는 프로퍼티로 전달한 함수를 사용해서 상태를 관리하는 컴포넌트까지 거슬러 올라와 상태를 변경할 수 있다. 갱신된 상태는 프로퍼티로 다시 하위 컴포넌트로 전달된다.

컴포넌트는 전체적인 상태를 관리 할 수 있으며 자식 컴포넌트에게 프로퍼티를 전달할 수 있다. 프로퍼티에 함수를 전달하는 방법으로 자식 컴포넌트가 부모컴포넌트의 상태를 변경할 수 있게 한다.

하지만 자식 컴포넌트는 전달된 함수의 출처가 어디인지, 프로퍼티로 받은 함수가 어떤 동작을 하는지 알지 못한다. 이 함수는 부모컴포넌트의 상태를 변경할 수도 있지만 다른 일을 할 가능성도 있다. 자식 컴포넌트는 단순히 실행하는 역할을 한다. 프로퍼티도 동일하다. 컴포넌트는 받은 프로퍼티가 프로퍼티인지, 상태인지, 또는 부모 컴포넌트에서 파생된 프로퍼티인지 알 방법이 없습니다. 자식 컴포넌트는 그저 사용할 뿐이다.

프로퍼티와 상태의 개념을 이해하는 일은 중요합니다. 컴포넌트 트리에서 사용하는 모든 속성은 프로퍼티와 상태로 나눌 수있다. 무엇이든 상호작용이 필요한 경우에는 상태에 보관되어야 한다.그 외 나머지는 모두 프로퍼티 형식으로 전달한다.

수준 높은 상태 관리 라이브러리를 사용하기 전에 컴포넌트 트리를 따라 프로퍼티를 보내본 적이 있어야 합니다. 가장 끝에 있는 자식 컴포넌트에서 특정 값을 사용하려고 중간 컴포넌트에서는 전혀 쓰지 않는, 수많은 프로퍼티를 전달하는 코드를 작성하면서 "분명 이보다 더 나은 방법이 있을 거야" 생각해본 적이 있어야 한다.

### 4. React 상태 옮기기

일반 React에서 지역 상태 관리를 확장하는데 가장 중요한 전략입니다. 상태 계층은 올릴 수도, 내릴 수도 있다.

다른 컴포넌트에서의 접근을 줄이기 위해 지역 상태 계층을 하위로 내릴 수 있다. 컴포넌트 A가 자식 컴포넌트로 B와 C를 갖고 있다고 상상해보자. B와 C는 A의 자식 컴포넌트로 동등하다. 컴포넌트 A는 유일하게 지역 상태를 관리하며 자식 컴포넌트에 프로퍼티를 전달한다. 덧붙여 B와 C에서 A의 상태를 변경할 수 있는 함수도 전달 합니다.

이제 컴포넌트 A의 지역 상태 절반은 컴포넌트 C에서 프로퍼티를 통해 쓰고 있으며 컴포넌트 B에서는 전혀 사용하고 있지 않다. 게다가 C는 A 컴포넌트에서 C에서만 사용하는 상태만 제어할수 있는 함수를 프로퍼티로 전달했따. 여기서 볼 수 있는것 처럼 컴포넌트 A는 컴포넌트 C를 대신해서 상태를 관리하고 있다. 대부분의 경우에는 한 컴포넌트가 자식 컴포넌트 모든 상태를 관리하는 일에 큰 문제가 없다. 하지만 컴포넌트 A와 컴포넌트 C 사이에 다른 컴포넌트가 추가되면 컴포넌트 A에서 컴포넌트 C에 전달해야 하는 프로퍼티를 많은 컴포넌트를 거쳐서 전달해야한다.

이런 경우가 React의 상태를 아래로 내려야 하는 완벽한 경우이다. 컴포넌트 A는 컴포넌트 C의 상태를 관리하고 있지만 이 상태 일부는 컴포넌트 C가 스스로 관리해도 문제가 없다. 즉, 각각의 상태에 대해 각 컴포넌트가 자율적으로 움직일 수 있다. 지역 상태 관리를 컴포넌트 C로 옮기면 더 이상 컴포넌트 트리를 따라 프로퍼티를 전달하지 않아도 된다.

컴포넌트 A의 상태도 깔끔해진다. 이 컴포넌트는 필요에 따라 자신의 상태와 가장 가까운 자식 컴포넌트의 상태만 관리하게 된다.

React에서 상태 옮기기는 다른 방향, 즉 상태 위로 옮기기도 가능하다. 부모 컴포넌트인 컴포넌트 A와 자식 컴포넌트인 컴포넌트 B,C로 돌아와서 살펴본다. A,B,C 사이에 얼마나 많은 컴포넌트가 있는지 상관 없다. 하지만 이번에는 컴포넌트 C가 이미 자신의 상태를 관리하고 있다.

만약 컴포넌트 B가 C에서 관리하는 상태가 필요하다면?? 이 상황에서는 공유 할 수 없다. 상태는 프로퍼티 형태로 아래로만 넘겨줄 수 있기 때문이다. 이런 이유에서 상태 계층을 위로 이동시킬 필요가 있다. 컴포넌트 C의 상태를 컴포넌트 B와 C가 공통으로 갖는 부모 컴포넌트의 위치로 올릴 수 있다. 만약 C가 관리하는 상태를 B에서 필요로 한다면 C는 상태 없는 컴포넌트가 된다. 상태는 A에서 관리 되며 B와 C에 공유된다.

 상태를 위로, 또는 아래로 옮기는 전략에서 단순 React를 사용할 때는 어떻게 상태 관리를 확장하는지 배울 수 있다. 더 많은 컴포넌트가 특정 상태에 관심을 가져야 하는 경우에는 상태에 접근해야 하는 컴포넌트 간의 공통 부모 컴포넌트까지 거슬러 올라가 상태를 둬야 한다. 덧붙여 지역 상태 관리에서 충분히 관리할 수 있다면 컴포넌트는 필요한 만큼 상태를 관리하고 있기 때문이다. 만약 컴포넌트 자체나 자식 컴포넌트에서 사용하지 않는 상태가 있다면 그 상태는 상태가 필요한 컴포넌트의 위치로 이동해야한다.


 ### 5. React의 고차 컴포넌트

고차 컴포넌트 (Higher order components, HOCs)는 React의 고급 패턴이다. 이 패턴은 추상적인 기능이 필요할 때 사용할 수 있으며, 여러 컴포넌트에서 선택적으로 기능이 필요할 때 활용할 수 있다. 고차 컴포넌트는 컴포넌트를 받아서 선택적 설정을 입력으로 받아 강화된 버전은 컴포넌트를 반환합니다. 이 기능은 JavaScript의 고차 함수 원칙인 함수를 반환하는 함수처럼 구현되어있다.

고차 컴포넌트는 뒤에서 더 중요해지는데 Redux와 같은 라이브러리를 사용하게 되면 마주하게 되기 때문이다. Redux 같은 라이브러리는 React의 뷰 계층와 라이브러리의 상태 관리 계층과 연결하게 되며 이 과정에서 고차 컴포넌트를 사용해 처리하게 됩니다.

 MobX와 같은 상태 관리 라이브러리도 동일한 방식으로 적용한다. 고차 컴포넌트는 라이브러리에서 제공하는 상태 관리 계층과 React의 뷰 계층을 붙이는데 사용한다.

### 6. React의 COntext API

React의 Context API는 드물게 사용된다. 이 API를 사용하라 충고하지 않는 편인데 이 API는 안정적이지 않고 애플리케이션의 묵시적 복잡도를 높이기 때문이다.

왜 이기능을 알아야할까? React의 context는 컴포넌트 트리에서 속성을 묵시적으로 전달할 때 사용된다. 부모 컴포넌트에서 속성을 context로 선언하면 컴포넌트 트리 아래에 있는 자식 컴포넌트에서 활용할 수 있다. 명시적으로 각각의 컴포넌트 계층에 일일이 전달할 필요 없이 단순히 부모-자식 관계라면 부모 컴포넌트가 생성한 context를 자식 컴포넌트가 집어 사용할 수 있습니다. 모든 컴포넌트 트리에 걸쳐 언제든 꺼내서 쓸 수 있는, 보이지 않는 컨테이너가 존재한다. 이 컨테이너 덕분에 컴포넌트에서 필요하지 않는 프로퍼티는 접근할 필요가 없어지기 때문에 React에서 프로퍼티 내려꽂기라고 하는 일을 피할 수 있게 된다. 왜 이런 api를 알아야 할까?

Redux나 Mobx 와 같은 세련된 상태 관리 라이브러리를 사용하다보면 어떤 시점에서 상태 관리 계층을 React 뷰 계층에 붙여야하는 상황이 생긴다. React의 고차 컴포넌트를 언급한 이유가 여기에 있다. 이 붙이는 과정을 통해 상태에 접근하고 수정할 수 있게 된다. 

하지만 어떻게 모든 컴포넌트에서 이 상태 컨테이너에 접근할 수 있도록 붙일 수 있을까. 이런 상황에서 React의 context를 사용할 수 있다. 최상위 컴포넌트 즉, React의 루트 컴포넌트에서 상태 컨테이너를 context로 지정한다. 그래서 컴포넌트 트리에 있는 모든 컴포넌트에 명시적으로 전달하지 않으면서도 모두 접근할 수 있게 된다. 이 모든 과정은 React의 프로바이더 패턴으로 적용할 수 있다.

무론 이런 방식을 사용한다는게 Redux 같은 라이브러리를 사용할 때마다 React의 context를 직접 제어할 필요가 있다는 의미가 아니다. 이런 라이브러리는 이미 모든 컴포넌트에서 상태 컨테이너에 접근 가능하도록 모든 기능이 함께 제공된다.

### 7. React의 상태 컴포넌트

React는 두 종류의 컴포넌트 선언이 존재하다. ES6 클래스 컴포넌트와 함수형 상태없는 컴포넌트이다. (현재는 hooks로 함수형 컴포넌트도 상태를 가질 수 있따!!!) 함수형 상태 없는 컴포넌트는 props를 인자로 받고 JSX를 반환하는 단순한 함수. 상태도 없고 lifecylce도 없다. (hooks엔 둘다 있따!!)

### 8. 컨테이너와 프레젠터 패턴

컴포넌트를 컨테이너와 프레젠터로 구분한다. 컨테이너 컴포넌트는 어떻게 동작하는 가를, 프레젠터 컴포넌트는 어떻게 보이는가를 정의한다. 컨테이너 컴포넌트는 ES6 클래스 컴포넌트로 구현되어 지역상태를 간리하고 프레젠터 컴포넌트는 함수형 상태없는 컴포넌트로 작성하여 플퍼티로 받은 내용을 표현하고 부모 컴포넌트로부터 받은 함수 몇가지를 실행하는 역할을 한다.

(요즘은 그냥 hooks로 다 함수형 컴포넌트로 하는게 대세인듯)