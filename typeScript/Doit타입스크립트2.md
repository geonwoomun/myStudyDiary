# 4장부터 5장까지

함수 선언문과 함수 표현식
void 타입, 함수 시그니처 () => void
type 키워드로 타입 별칭을 만들 수 있음.
type alias

함수는 객체다, 일급 함수. -> 변수와 함수를 구분하지 않는다.

화살표 함수

배열 메서드 filter, map, reduce

### readonly
readonly 타입으로 선언된 매개변숫값을 변경하는 시도가 있으면 다음처럼 문제가 있는 코드라고 알려줘서 불순 함수가 되지 않게 방지한다.

불변과 가변 const나 readonly로 명시하고 있으면 변숫값은 초깃값을 항상 유지한다. 이런 변수는 변경할 수 없다는 의미로 불변(immutable) 변수라고 한다. 반면에 let이나 readonly를 명시하지 않은 변수는 언제든 값을 변경할 수 있다. 가변(mutable)변수라고 한다.

const 키워드가 있는데 readonly가 왜 필요한가?
타입스크립트에서 인터페이스, 클래스, 함수의 매개변수 등은 let이나 const키워드 없이 선언한다. 따라서 이런 심벌에 const와 같은 효과를 주려면 readonly라는 타입수정자가 필요하다.

### 깊은 복사와 얕은 복사

깊은 복사는 대상 변숫값이 바뀔 때 원본 변숫값은 그대로인 형태로 동작한다.

number, boolean, string은 깊은 복사로 동작한다.

객체와 배열은 얕은 복사 방식으로 동작한다. 그래서 spread 연산자를 통해 깊은 복사를 할 수 있다.

sort, filter를 통해 순수한 정렬, 삭제 함수를 구현할 수 있다.

가변 인수 함수는 함수 매개변수 쪽에 ...arrays 를  통해 몇개를 받던 상관없게 만들 수 있다.

    export const mergeArray = <T>(...arrays: readonly T[][]): T[] => {}