# 스캐너
Lexical Analyzer 스캐너

스캐너는 프론트엔드에 속해있는 중요한 것.

컴파일러 → 프론트엔드 IR 백엔드로 구성

프론트엔드의 목적은 입력언어로 작성된 프로그램을 분석하는데 역할이 있다.

분석해서 IR의 형태로 변환해주는 것.

작성하는 코드들은 입력 랭기지에 포함되어 있어야하고, 문법적으로 잘 구성되어있어야함.

입력된 소스코드를 IR형태로 변환해주는 것. 주로 문법 분석, 의미 분석을 통해 정상적으로 머신코드로 변환 될 수 있는 녀석인지, 머신코드로 변환되기 변환되기전 IR로 변환해서 백엔드에서 추가적인 명령어선택이나 최적화 같은 다양한 역할을 처리하기 편리하게 만들어준다.

Frontend는 스캐너와 파서로 구성되어있음.

스캐너 regular expressions로 표현. 오토제너레이터 lex,  parser는 yacc을 쓰게 된다.

RE를 넣으면 자동으로 스캐너가 생성되게 하는 오토제너레이터를 사용하게 된다. RE를 입력으로 넣으면  내부적으로 deterministic finite automaton(DFA)형태로 바뀌게 됨. 코드형태로 최종적으로 변환이 된다.

parser도 마찬가지 context-free grammars를 입력으로 넣게 되고 push-down automaton을 거쳐서 코드로 변환.

오토제네레이터를 사용하면서 엔지니어가 할일이 많이 줄어들었다. 다양한 언어가 쏟아지더라도 빠르게 대응할 수 있다.

프론트엔드를 왜 하나로 만들지 않고 두개로 나눠서 구성하느냐.

하는 일 자체가 기본적으로 다르다.

스캐너는 단어를 분류하고 토큰의 형태로 변환.

스캐너는 단순작업 단순히 아이디인지 넘버인지 오퍼레이터인지 나눠서 토큰의 형태로 변환을 하는 단순한 작업만 수행.

파서는 문법 적용, 의미적으로 이것이 맞는건지 분류를 하게 돼서 .. 

역할이 다른게 이유이고, 또 두개를 하나로 붙였을 때 작업이 복잡했었다. 아예 분리시켜서 스캐너 파서라는 형태로 나누게 되었다. 하는 일 자체가 다르다는게 가장 큰 이유.

파싱자체가 훨씬 복잡하고 느리다. 

작업이 좀 더 복잡하다. 스캐너가 굉장히 심플해짐. 스캐너와 파서가 전부다 단순해짐. 

토큰은 <type, value>의 pair 형태로 구성됨. 

스캐너는 입력으로 들어온 인풋스트링을 토큰 형태로 변환. 토큰은 문법의 가장 작은 단위가 된다.

ex) x = x + y 는 <id, x> = <id, x> + <id, y>

언어의 문법의 다양한 부분들을 이해할 수 있게 된다. 그 이후에 파서에서 이런것들을 이용해 다양한 추가적인 작업을 할 수 있게 도와주게 된다.

## Examples

234 * (56 + 79)로 되어있으면 

234: number

*: multiplication

(: left parenthesis

56: number

+: addtion

79: number

): right parenthesis

토큰이 가지고 있는 기본적인 형식을 따르지 못 한다면 Error를 발생한다.

컴퓨터 입장에선 코드를 토큰으로 분리하는건 굉장히 어려운 일 . 그래서 RE가 필요하다. RE를 가지고 lex 같은 스캐너 제너레이터를 통해 스캐너를 생성한다.

모든 것을 if else로 복잡하게 작성해야함. 단순히 코드로 짯다가는... ㅠ

현실적으론 불가능하고 이것들을 할 수 있게 만들어주는게 state machine이다. state와 입력이 들어왔을 때 transition 되는 target state로 구성된다. 

S0 : state f: transition, S1: target state

 

state 개수가 한정적인 것을 Finite state machine (FSM) 이라고 부름. 대부분 이렇게 구성되어있음

손쉽게 소프트웨어나 하드웨어를 구성할수가 있다. 일종의 설계도.

스캐너를 손으로 직접 작성하는 것은 보통 어려운일이 아니다. 지루하고 복잡하고 피곤한 일이다. 스캐너 제너레이터를 사용하게 된다. 어떻게 작동하는지 살펴본다.

디자인 타임에 스캐너에 대한 명세가 들어온다. 명세는 흔히 레귤러 익스프레션이라고 불리는 정규표현식을 따르고 있다. 정규표현식 형태로 Specifications를 만들고 스캐너에 입력으로 주게 되면 스캐너가 생성이 되는데 이때 추가적으로 테이블이나 코드들을 수정할 수 있다. 스캐너가 만들어지면 실제로 컴파일러가 컴파일 할 때 컴파일타임에 소스코드를 받아서  토큰형태로 변환하게 된다. 레귤러익스프레션은 토큰을 어떻게 나눌 것인가하는게 포함되어 있을 것이다.

이것을 통해서 스캐너의 구현을 굉장히 단순하게 할 수 있다.

## Regular Languages?

형식적인 언어이다. regular expression을 이용해서 표현될 수 있는 형식 언어이다. 내추럴 랭기지랑 다르다. 자연어는 굉장히 자유롭다. 언어가 형태가 변하기도 하고 동일한 말도 다른 의미를 가지고... formal한 랭기지는 제한적인 언어를 말한다. 프로그래밍 랭기지 같은.

formal language는 룰에 의해 제한되고 있는 랭기지를 의미한다. 룰에 의해 제한되어지는게 중요.

RE의 예

{a,b}의 모든 조합을 시그마로 표현 해보면. a|b 또는 이니깐 {a, b} 

(a|b)(a|b) 는 {aa, ab, ba ,bb } (a|b)(a|b) = aa|ab|ba|bb 로 가능

a*은 {아무것도 없는 것., a, aa,aaa,...}

(a|b)* 는 a와 b로 구성할 수 있는 모든 문자열

a| a*b는 a 또는 a*b  ⇒ {a, b, ab, aab, aaab,....}

대수적인 특성들을 가지고 있음, 교환법칙, 결합 법칙, 분배법칙, 앱실론, null과 같은 없다..*도 같이 쓸수가 있다. ** 은 *과 같다. *은 앱실론을 포함.

identifier 여러가지 변수명들.. 문자로 시작해야하고 그 뒤에 문자나 숫자가 개수에 상관없이 올 수 있다.

letter ⇒ 대소문자

digit ⇒ 0~9 숫자

id → letter(letter|digit)*

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f5710f9-783f-4e30-bb14-13d7ac3d190b/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f5710f9-783f-4e30-bb14-13d7ac3d190b/Untitled.png)

 

Number는

interger 덧셈뺄셈 숫자. 연속적으로~

(+|-|e)(0|(1|2|...|9)digit*)

decimal → integer.digit*

real → (integer|decimal)E(+|-)digit+

complex → `(`real`,`real`)`

이 RE를 통해서 스캐너를 디자인하게 된다.

# 스캐너2

문자열을 판독해서 RE에 맞는 문자열이다 라고 판단하는 것을 recognizer라고 한다. 문자열 x를 받아서 문자열 x에 해당하는 내용이면 yes를 내보낸다. 이런것들이 여러 개 스캐너 안에 존재한다.

RE는 FA와 동일하다.

RE를 이용해서 DFA를 생성하게 된다.

이걸 기반으로 스캐너 코드가 오토 제네레이션 된다.

스캐너를 만들 때 해야할일 :

DFA를 생성하고, state 머신을 최소화 하는 기술을 적용하고, 스캐너 코드 생성

identifier 문자로 숫자로 구성. 대체적으로 변수명이라고 생각하면 된다.

letter나 digit으로 구성되어있는데, id는 문자로 시작하고 문자 또는 숫자의 개수에 제한 없이 연속적으로 나온다.

STATE 머신으로 나타내면 

S0 → letter → S1 letter | digit → other → S2

처음에 숫자 아니면 S3 error!

NFA를 DFA로 만드는 것이 중요하다.🧚‍♀️

NFA ↔ DFA 차이는 뭘까

Nondeterministic Finite Automation(NFA)

동일한 입력에도 다른 STATE 으로 갈 수 있으면 NFA 

DFA는 그렇게 못 함.  하나의 STATE에서 하나의 입력에는 정해진 하나의 STATE로만 가야함.

DFA로 구현하는게 어렵다

NFA는 RE를 보면 직관적으로 바로 할 수 있는데 DFA는 그렇게 할 수 없다. 그래서 RE → NFA → DFA 순으로 가게 된다.

DFA는 NFA의 스페셜한 케이스라고 보면 된다.

앱실론 트랜지션이 존재하지 않는 상태다. 각각의 state s에서 입력 심볼 a가 들어오면 하나의 edge에만 갈 수 있다. 특정한 하나의 state에만 갈 수 있다. 이렇게 dfa로 구성해야 스캐너를 만들 수 있다.

유니크한 path를 가지고 있어야한다. DFA는 NFA의 subset이다. DFA는 NFA를 이용해서 시뮬레이션 할 수 있다. NFA는 DFA로 변환이 가능하다.

e-moves : e 는 null과 유사하다. 특정한 입력이 들어와야하는데 안 들어온 것. e 그럼에도 s0에서 s1로 상태전이가 발생한 것. 이런걸 e-moves. 상식적으론 있을 수 없지만 NFA를 구성할 때는 e-moves를 표현해주는 것이 훨씬더 편리하고 이해하기 좋다.

1. RE → NFA W/e-moves

    NF로 반들고 e-moves로 연결한다.

2. NFA W/e-moves to DFA

    NFA로 DFA를 만든다.

3. DFA → Minimized DFA

    DFA를 최소화한다.

 4.   DFA → RE

 이 작업을 반복시킨다. 자주 발생하진 않음

RE를 NFA로 만드는 것. 

Thompson`s construction 각각의 연산이나 심볼들을 N(x)로 표현. 이렇게 표현된 터미널들을 e-moves로 연결해준다.

NFA가 무지 크기 때문에 DFA로 바꾸고 최소화까지 하게 되면 엄청 간단해진다.

# 스캐너3

NFA를 DFA로변환하는 과정을 해본다.

DFA를 이용해서 NFA를 시뮬레이션하는 형태로 구성해야한다.

키 함수. Move(si,a) si 인상태에서 a라는 입력이 들어왔을 때 도달 가능한 상태.

ex) S0 a - s1, b- s2, a-s3 이렇게 했다 하면 Move(s0,a) = {s1,s3}가 된다. a라는 입력에 의해서 도달 가능한 state의 집합.

e-closure(si) : e을 이용해서 도달 가능한 state의 집합.

알고리즘은 굉장히 단순하고 반복적으로 이루어진다. NFA의 s0로부터 시작하게 되고. s0에 대한 e-closure를 찾는다. DFA의 state S0로 선언. S0 Move 함수를 취하게 되고 e-cloure을 취한다.

기존에 있던 DFA의 상태가 아니면 기존에 있던 e-closure랑 다른 상태면 추가하게 된다. S1, S2... 추가적인 state가 없을 때까지 반복적으로 작업.

DFA의 state는 NFA의 Move와 e-closure로 구성을 할 수가 있다. 말로 하면 어렵다. 예를 들어 보자...

a ( b | c) *

NFA로 table을 만들게 되면 DFA로 만들기 가능.

NFA 구성으로부터 알고리즘 적용해서 DFA로 만들기 가능.

DFA는 NFA에 비해서 e-move가 존재하지 않기 때문에 심플. 하나의 입력에 대해서 하나의 결과만 나옴. 동일한 구성을 하지만, 훨씬 더 중요한 핵심 내용들만 있다. 스캐너를 개발할 때 훨씬 깔끔하고 단순하게 프로그램으로 개발할 수 있는 형태가 되는 것이다. 

우리의 목표는 훨씬 더 높다. DFA 다음에 또다른 단계들이 있다.

그 다음 단계 DFA를 최소화하는 것. 훨씬 더 컴팩트하게.. 대표적으로 Hopcroft 알고리즘. 깊게 배우면 한 학기 동안 다 배워야 하기 때문에 간단하게만 배울 것임.

DFA 최소화 큰그림

DFA 안에 있는 등가 STATE (equivalent states) 를 발견해서 SINGLE STATE로 만들어주는 작업을 반복적으로 수행.

등가 state를 찾는거 보다 비등가 state를 다 찾아서 제거해주면 남는 것은 등가 state이다.

비등가 state란 X,Y가 비등가이려면 X는 final인데 Y가 아니다. 역도 성립, x와 y라는 state가 입력 a 가 들어왔을 대 X` Y`로 이동하게 되는데 X`, Y`가 비등가면 X와 Y도 비등가이다. (inequivalent)

final인게 뭔가 final state가 q9다. q9를 포함하고 잇으면 final state이다. s1, s2, s3 / s0는 final이 아님

s0 와 s1 s2 s3는 같지 않다. 

s1 s2 s3는 일단 같다. X, Y 가 있을 때 동일한 입력이 입력 되었을 때 X`, Y`가 inequivalent 하지 않으면 X, Y도 inequivalent이다.

뭐가 들어와도 같은 결과를 나타내니 s1 s2 s3는 Equivalent 하다. 

   

모든 입력언어를 표현할 수는 없다. RE의 한계가 존재. 반복을 할수있는데 *을 사용하여. 임의의 반복횟수를 지정할 수 없다.

모든 language가 regular하진 않다. balanced하게 돼야하는 거 re로 표현하기 어려운 nested 디자인 형태도 표현할 수 없다.

re에서 표현이 안 되는 것들은 Parser에서 처리 

RE의 장점. 패턴을 표현하는 것에 있어서 단순하고 강력함.

이것을 통해 스캐너를 자동으로 생성할 수 있다는 것은 큰 장점.

많은 종류의 문법을 re로 표현 가능.