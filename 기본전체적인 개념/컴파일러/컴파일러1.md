Compiler는 High-Level Language를 Low-Level Languages로 변환해주는 소프트웨어다.

하이레벨 랭기지 레벨이 높을 수록 인간에 가깝다. C나 C++, 자바, 파이썬 같은 프로그래밍 랭기지라고 한다.

로우레벨 랭기지에는 어셈블리라는 언어가 대표적이다.

좀 더 기계, 컴퓨터에 가깝다.

그래서 우리가 컴파일러를 생각하게 되면 VS 같은 IDE를 떠올릴텐데, IDE라는건 컴파일러만 포함된게 아니라 소스 에디터나 디버거 같은 소프트웨어가 포함되어 있는 것인데,  컴파일러를 배워 볼 것이다. 

컴파일러는 컴파일 타임과 런타임에  하나의 언어를 다른 언어로 변환하는 것이다. 

컴파일 타임(실행 되기전에) 런타임(실행되고 나서)

A = B + C 

스태틱컬리를 하면 B가 바이너리, .exe 같은 바이너리 파일로 변환이 되서

다이내믹 컴플리케이션 같은 경우에는 코드가 미리 바이너리 파일로 변환 돼있는게 아니라 코드 상태로 되어있다가, 프로그램이 실행되는 경우에 바이너리로 변환 돼서 실행한다.

스태틱 가장 대표적인 c c++, 런타임에 가장 대표적인게 java, python

런타임 컴플레이션을 하게 되면 VM이 필요하다. JAVA는 JVM이 있다. execution 엔진이라고 부른다. 이런 것들이 필요하게 된다. 런타임에 컴플레이셔 하고 실행까지 하게 된다. 모든 언어가 항상 고정되어있는게 아니고 계속해서 변한다.

자바 같은 경우 2가지를 거친다. 

안드로이드 같은경우 미리 바이너리로 다 바꿔서 실행을 해서 실행속도를 올려주는 동작.

컴파일러의 역할 : 프로그램을 읽고 이해할 수 있다.

어떤 동작을 수행해야 하는지를 정확히 판단해야한다.

실행될 액션을 어떻게 실행할지를 설명할 수 있어야한다.

컴퓨터에게 프로그래머가 원하는 동작을 실행하라고  어떻게 실행하라고 알려줘야한다.

성능을 결정짓는 아주 중요한 요소.

애플리케이션의 실행 성능을 높이는데에는

HW, SW 방법이 있다. HW 저성능의 프로세서를 고성능의 GPU나 더 고성능의 프로세스를  사용해서 개선 가능. 비용이 많이 든다. 10개의 컴퓨터를 이용해서 프로그램을 가동하고 싶다면 10배의 비용이 들게 된다.

SW 컴파일러를 개선함으로써 성능이득을 얻게 되면 그만큼 큰 성능을 얻게 되면서도 비용이 줄게된다.

프로그랭귀지로 프로그램을 만들려면

알고리즘 → 특별한 랭기지를 사용해서 프로그래밍을 하게 되는데, 이러한 프로그래밍 한 것을 컴파일러가 컴파일해서 머신 코드로 바꾸고 실행.

V

프로그래밍 랭기지의 특성 :

1. 모호하지 않다. 하나의 역할을 하게된다.
2. 정확해야한다.
3. 간결해야한다.
4. 표현력이 있어야한다.
5. 추상적으로 표현할 수 있어야한다.

컴파일러가 왜 중요한가?

소프트웨어의 꽃이라 부른다. 꽃 2개 OS, 컴파일러

2가지다 시스템 소프트웨어라고 부르는 녀석들이다. 시스템 소프트웨어는 일반적인 어플과 다르게. 어플을 실행할 수 있게 도와주는 소프트웨어. 구조도 복잡하고 많은 알고리즘을 포함하고 있다.

소프트웨어와 하드웨어 사이의 다리 역할을 한다. 하나의 통역가 같은 느낌. 소프트웨어를 하드웨어가 얼마나 잘 이해할수 있는 코드로, 최적화된 형태로 바꿔주느냐에 따라 성능이 좌우된다. 그 역할을 해주는 것도 컴파일러를 잘 디자인 했냐 못 했냐에 따라 달라지기 때문에 컴파일러의 성능이 중요하다.

하드웨어가 굉장히 빠른 속도로 변하고 있다. C나 C++은 처음과 그렇게 많이 변하지 않았다. 그 당시에 사용했던 하드웨어 10~20년 전에 사용했던 마이크로 프로세서와 지금은 하늘과 땅차이이다. 기존에 없던 아키텍처들이 만들어지기 시작. 그렇다고 각각의 아키텍처마다 새로운 랭기지를 익힐 순 없다. C, C++, 자바, 파이썬(파이썬처럼 새로 나온?) 누가 하드웨어 매칭시켜줘야하나 ?컴파일러가 매칭시켜줘야한다.

컴파일러 엔지니어만 조금 고생해주면 된다.

굉장히 많은 다양한 프로세서의 종류들이 있다. 그 사이에서 가교 역할을 하는 컴파일러는 굉장히 중요하다.

새로운 아키텍처들이 나오니깐 새로운 프로그래밍 언어, 이러한 모델들을 뒷받침 하기 위한 새로운 프로그래밍 모델들이 나왔다.

병렬처리를 위한 OpenMp(멀티코어) OpenCl/CUDA (GPGPU)들이 나왔다.

하드웨어의 변경없이도 높은 성능을 얻을 수 있다. 컴파일러 최적화.

컴파일러의 개선만으로 엄청난 성능향상이 있을 수 있다.

머신러닝의 경우: 머신러닝을 어떻게 하면 빠르게 할 수 있을까, 기존에는 GPGPU 를 사용. 그래픽카드 게임할 때.. GPGPU로도 안되겠다...! 그래서 나온게 DPU 같은 딥러닝 프로세스.. 폰노이만 아키텍처를 따르면서도... 비정형화된. 굉장히 많은 분야에서 컴파일러 인력을 필요로 한다. 학부생 수준에서 배우기엔 어려운 기술. 석사, 박사, 소프트웨어 하드웨어 사이의 연결 지점에 있기 때문에 둘다를 이해할 수 있어야 하고 다양한 랭기지를 알고 있어야한다. 

우리가 알고 있떤 랭기지를 스캐닝하고 파씽 하고 그런 기본적인 랭기지를 분석하는 역할만 있는 것이 아니라, 백엔드쪽 하드웨어에 어떻게 하면 최적화 할 수 있는지 하드웨어를 변환하는 기능 다양한 역할들을 수행하고 있다.